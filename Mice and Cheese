There are two mice and n different types of cheese, each type of cheese should be eaten by exactly one mouse.
A point of the cheese with index i (0-indexed) is:
reward1[i] if the first mouse eats it.
reward2[i] if the second mouse eats it.
You are given a positive integer array reward1, a positive integer array reward2, and a non-negative integer k.
Return the maximum points the mice can achieve if the first mouse eats exactly k types of cheese.
 

Example 1:

Input: reward1 = [1,1,3,4], reward2 = [4,4,1,1], k = 2
Output: 15
Explanation: In this example, the first mouse eats the 2nd (0-indexed) and the 3rd types of cheese, and the second mouse eats the 0th and the 1st types of cheese.
The total points are 4 + 4 + 3 + 4 = 15.
It can be proven that 15 is the maximum total points that the mice can achieve.


Example 2:

Input: reward1 = [1,1], reward2 = [1,1], k = 2
Output: 2
Explanation: In this example, the first mouse eats the 0th (0-indexed) and 1st types of cheese, and the second mouse does not eat any cheese.
The total points are 1 + 1 = 2.
It can be proven that 2 is the maximum total points that the mice can achieve.
 

Constraints:

1 <= n == reward1.length == reward2.length <= 105
1 <= reward1[i], reward2[i] <= 1000
0 <= k <= n






Soln :-


Java
class Solution {
    public int miceAndCheese(int[] reward1, int[] reward2, int k) {
        int n=reward1.length;
        int[]a=new int[n];
        int res=0;
        for(int i=0;i<n;i++){
            a[i]=reward1[i]-reward2[i];
            res+=reward2[i];
        }
        Arrays.sort(a);
        reverse(a);
        for(int i=0;i<k;i++)
            res+=a[i];
        return res;        
    }
    public void reverse(int[]a){
        int n=a.length;
        int i=0,j=n-1;
        while(i<j){
            int t=a[i];
            a[i]=a[j];
            a[j]=t;
            i++;
            j--;
        }
    }
}

C++
class Solution {
public:
    int miceAndCheese(vector<int>& r1, vector<int>& r2, int k) {
        priority_queue<pair<int,pair<int,int>> >pq;
        int n =r1.size();
        unordered_set<int> st;
        for(int i=0;i<n;i++){
            pq.push({r1[i]-r2[i],{r1[i],i}});
                
        }
        int ans =0;
       
        while(k && !pq.empty()){
            ans += pq.top().second.first;
            st.insert(pq.top().second.second);
            pq.pop();
            k--;
        }
       
        for(int i=0;i<n;i++){
          if(!st.count(i)){
              ans += r2[i];
          }
        }
        return ans;
        
    }
};
