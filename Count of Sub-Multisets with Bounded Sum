You are given a 0-indexed array nums of non-negative integers, and two integers l and r.

Return the count of sub-multisets within nums where the sum of elements in each subset falls within the inclusive range of [l, r].

Since the answer may be large, return it modulo 109 + 7.

A sub-multiset is an unordered collection of elements of the array in which a given value x can occur 0, 1, ..., occ[x] times, where occ[x] is the number of occurrences of x in the array.

Note that:

Two sub-multisets are the same if sorting both sub-multisets results in identical multisets.
The sum of an empty multiset is 0.
 

Example 1:

Input: nums = [1,2,2,3], l = 6, r = 6
Output: 1
Explanation: The only subset of nums that has a sum of 6 is {1, 2, 3}.
Example 2:

Input: nums = [2,1,4,2,7], l = 1, r = 5
Output: 7
Explanation: The subsets of nums that have a sum within the range [1, 5] are {1}, {2}, {4}, {2, 2}, {1, 2}, {1, 4}, and {1, 2, 2}.
Example 3:

Input: nums = [1,2,1,3,5,2], l = 3, r = 5
Output: 9
Explanation: The subsets of nums that have a sum within the range [3, 5] are {3}, {5}, {1, 2}, {1, 3}, {2, 2}, {2, 3}, {1, 1, 2}, {1, 1, 3}, and {1, 2, 2}.
 

Constraints:

1 <= nums.length <= 2 * 104
0 <= nums[i] <= 2 * 104
Sum of nums does not exceed 2 * 104.
0 <= l <= r <= 2 * 104



Soln :-
Java
class Solution {
    static final int MOD = 1_000_000_007;

    public int countSubMultisets(List<Integer> nums, int l, int r) {
        TreeMap<Integer, Integer> numsMap = new TreeMap<>();
        for (int num : nums) {
            numsMap.put(num, numsMap.getOrDefault(num, 0) + 1);
        }

        long[] cache = new long[r + 1];
        cache[0] = 1;

        for (Map.Entry<Integer, Integer> entry : numsMap.entrySet()) {
            int num = entry.getKey();
            int freq = entry.getValue();

            // preprocessing
            long[] pSum = Arrays.copyOf(cache, r + 1);
            for (int i = 0; i <= r; ++i) {
                if (i >= num) {
                    pSum[i] += pSum[i - num];
                    pSum[i] %= MOD;
                }
            }

            // update dp cache
            for (int i = r; i >= 0; --i) {
                if (num > 0) {
                    int j = i - (freq + 1) * num;
                    cache[i] = pSum[i] - (j >= 0 ? pSum[j] : 0);
                    cache[i] = Math.floorMod(cache[i], MOD);
                } else {
                    cache[i] *= freq + 1;
                    cache[i] %= MOD;
                }
            }
        }

        long res = 0;
        for (int i = l; i <= r; ++i) {
            res += cache[i];
            res %= MOD;
        }
        return (int) res;
    }
}


C++
class Solution {
public:
    int countSubMultisets(vector<int>& A, int l, int r) {
        vector<int> dp(20010);
        dp[0] = 1;
        int mod = 1e9 + 7;
        unordered_map<int, int> count;
        for (int a : A)
            count[a]++;
        for (auto it = count.begin(); it != count.end(); ++it) {
            int a = it->first, c = it->second;
            for (int i = r; i > max(0, r - a); --i) {
                long v = 0;
                for (int k = 0; k < c && i - a * k >= 0; ++k) {
                    v += dp[i - a * k];
                }
                for (int j = i; j > 0; j -= a) {
                    if (j - a * c >= 0)
                        v = (v + dp[j - a * c]) % mod;
                    v = (v - dp[j] + mod) % mod;
                    dp[j] = (dp[j] + v) % mod;
                }
            }
        }
        long res = 0;
        for (int i = l; i <= r; ++i)
            res = (res + dp[i]) % mod;
        return res * (count[0] + 1) % mod;
    }
};
